
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <meta
            name="pmd docs"
            content="documentación para programación con memoria dinámica"
        >
    <title>PMD 2022</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-c9d8fa83.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-953e3353.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-b12a2749.js"></script>

    <script>
      $(function() { setupCodeCopy(); });
    </script>
  </head>

  <body class="index" data-languages="[&quot;c&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-5ac488f6.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="c">c</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#conferencias" class="toc-h1 toc-link" data-title="Conferencias">Conferencias</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#sesion-0" class="toc-h2 toc-link" data-title="Sesión 0">Sesión 0</a>
                  </li>
                  <li>
                    <a href="#sesion-1" class="toc-h2 toc-link" data-title="Sesión 1">Sesión 1</a>
                  </li>
                  <li>
                    <a href="#sesion-2" class="toc-h2 toc-link" data-title="sesión 2">sesión 2</a>
                  </li>
                  <li>
                    <a href="#sesion-3" class="toc-h2 toc-link" data-title="Sesión 3">Sesión 3</a>
                  </li>
                  <li>
                    <a href="#sesion-4" class="toc-h2 toc-link" data-title="Sesión 4">Sesión 4</a>
                  </li>
                  <li>
                    <a href="#sesion-5" class="toc-h2 toc-link" data-title="Sesión 5">Sesión 5</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#ejercicios" class="toc-h1 toc-link" data-title="Ejercicios">Ejercicios</a>
          </li>
          <li>
            <a href="#herramientas" class="toc-h1 toc-link" data-title="Herramientas">Herramientas</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#editores-amp-ides" class="toc-h2 toc-link" data-title="Editores &amp; IDEs">Editores &amp; IDEs</a>
                  </li>
                  <li>
                    <a href="#vcs" class="toc-h2 toc-link" data-title="VCS">VCS</a>
                  </li>
                  <li>
                    <a href="#toolchain" class="toc-h2 toc-link" data-title="Toolchain">Toolchain</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#guia-de-estilo" class="toc-h1 toc-link" data-title="Guía de estilo">Guía de estilo</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#longitud-de-linea" class="toc-h2 toc-link" data-title="Longitud de línea">Longitud de línea</a>
                  </li>
                  <li>
                    <a href="#comentarios" class="toc-h2 toc-link" data-title="Comentarios">Comentarios</a>
                  </li>
                  <li>
                    <a href="#estructuras-condicionales" class="toc-h2 toc-link" data-title="estructuras condicionales">estructuras condicionales</a>
                  </li>
                  <li>
                    <a href="#switches" class="toc-h2 toc-link" data-title="Switches">Switches</a>
                  </li>
                  <li>
                    <a href="#funciones" class="toc-h2 toc-link" data-title="Funciones">Funciones</a>
                  </li>
                  <li>
                    <a href="#indentacion" class="toc-h2 toc-link" data-title="Indentación">Indentación</a>
                  </li>
                  <li>
                    <a href="#ciclos-de-repeticion" class="toc-h2 toc-link" data-title="Ciclos de repetición">Ciclos de repetición</a>
                  </li>
                  <li>
                    <a href="#apuntadores" class="toc-h2 toc-link" data-title="Apuntadores">Apuntadores</a>
                  </li>
                  <li>
                    <a href="#variables" class="toc-h2 toc-link" data-title="Variables">Variables</a>
                  </li>
                  <li>
                    <a href="#tipos-estructurados" class="toc-h2 toc-link" data-title="Tipos estructurados">Tipos estructurados</a>
                  </li>
              </ul>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a></li>
            <li><a href='https://creativecommons.org/licenses/by-nc-sa/4.0/'>Licence</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='conferencias'>Conferencias</h1><h2 id='sesion-0'>Sesión 0</h2>
<ul>
<li>Introducción al curso.</li>
<li>Revisamos puntos importantes de la guía de aprendizaje.

<ul>
<li>Metodos y notas importantes sobre el esquema de calificaciones y evaluaciones.</li>
<li>Donde encontrar los recursos del curso, como <code>docs</code>, <code>github</code> etc.</li>
<li>Se presento la metodologia de clase.</li>
</ul></li>
</ul>
<h2 id='sesion-1'>Sesión 1</h2><h3 id='prefacio'>prefacio</h3>
<p>se asume una cierta familiaridad con una <code>cli</code>, si este no es el caso, podemos estudiar como funcionan.</p>

<p>a recordar los comandos que vimos:</p>

<table><thead>
<tr>
<th style="text-align: center">commando</th>
<th style="text-align: center">descripción</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center"><code>cls</code></td>
<td style="text-align: center">limpiar la pantalla de la consola</td>
</tr>
<tr>
<td style="text-align: center"><code>pwd</code></td>
<td style="text-align: center">responde a <code>donde estoy?</code>, imprime el directorio actual</td>
</tr>
<tr>
<td style="text-align: center"><code>ls</code></td>
<td style="text-align: center">lista los archivos del directorio actual</td>
</tr>
<tr>
<td style="text-align: center"><code>cd</code></td>
<td style="text-align: center">para cambiarnos de directorio</td>
</tr>
</tbody></table>
<h3 id='repositorio-local'>repositorio local</h3>
<p>es un directorio con git inicializado. (i.e <code>git init</code>), por lo tanto, el folder <code>.git</code> existe.
para &quot;desinstalar&quot; <code>git</code>, es suficiente borrar el folder <code>/.git</code>.
Tradicionalmente contiene codigo, instrucciones de compilacion, y un archivo <code>.gitignore</code>.</p>
<h3 id='repositorio-remoto'>repositorio remoto</h3>
<p>Es una copia de un <code>repo</code> local, pero en un servidor remoto. (i.e <code>github</code>, <code>gitlab</code> etc.)</p>
<h3 id='comandos-notables'>comandos notables</h3>
<table><thead>
<tr>
<th style="text-align: center">commando</th>
<th style="text-align: center">descripción</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center"><code>git init</code></td>
<td style="text-align: center">inicializa un repo de git</td>
</tr>
<tr>
<td style="text-align: center"><code>git status</code></td>
<td style="text-align: center">obtiene el estado actual del repositorio</td>
</tr>
<tr>
<td style="text-align: center"><code>git add %ARGS%</code></td>
<td style="text-align: center">agrega archivos al <code>tracking</code></td>
</tr>
<tr>
<td style="text-align: center"><code>git commit</code></td>
<td style="text-align: center">&quot;comete&quot; (o guarda) los cambios a git</td>
</tr>
<tr>
<td style="text-align: center"><code>git branch</code></td>
<td style="text-align: center">muestra todas las ramas del repo</td>
</tr>
<tr>
<td style="text-align: center"><code>git checkout %ARGS%</code></td>
<td style="text-align: center">cambia a la rama deseada</td>
</tr>
<tr>
<td style="text-align: center"><code>git merge</code></td>
<td style="text-align: center">une dos ramas</td>
</tr>
</tbody></table>
<h3 id='single-player-git'>Single-player git</h3>
<p>durante el curso (quizá a excepcion del proyecto) jugaremos <strong>single-player</strong> git. por lo tanto, las poderosas
funciones de colaboración usualmente no las usaremos. el <em>&quot;flow&quot;</em> de trabajo que se recomienda es el siguiente:</p>

<ol>
<li><code>git init</code> en el repo local deseado.</li>
<li>crear archivo <code>.gitignore</code> siguiendo el <code>boilerplate</code> del curso.</li>
<li><code>git add .</code> para agregar todos los archivos al <code>branch</code> por defecto ( i.e <code>main</code> ).</li>
<li><code>git commit -m &quot;First commit&quot;</code> para crear un punto inicial del historial.</li>
<li><code>git checkout -b &quot;feat/mi-nuevo-feature&quot;</code> para crear y cambiarnos a un branch nuevo.</li>
<li>programar el feature necesario hasta estar satisfechos con los cambios.</li>
<li>cada cierto tiempo guardar los cambios a git (<code>git add .</code> si creamos archivos, <code>git commit -m &quot;descripcion de mi cambio&quot;</code>)</li>
<li>una vez terminado el feature, <code>git checkout main</code> para regresar a nuestra <code>branch</code> principal.</li>
<li><code>git merge feat/mi-nuevo-feature</code> para unir las dos ramas, e inmediatamente despues borrar <code>git branch -d feat/mi-nuevo-feature</code> la branch vieja.</li>
<li>regresar al paso 5 si existen features por implementar.</li>
</ol>

<p>opcionalmente, si queremos publicar nuestro trabajo a github, desde la branch deseada <code>git push</code>.</p>

<p>si el repo que queremos manipular esta en un repositorio remoto, es suficiente <code>git clone %URL%</code> para crear el repo local, regresar al paso 1.</p>

<p>si tenemos un <code>repo</code> local que desconoce de la existencia de un <code>repo</code> remoto, es necesario usar <code>git remote add</code> para registrarlo.</p>
<h3 id='tldr'>tldr</h3>
<p><code>git</code> es un <strong>VCS</strong>. Es útil para desarrollar secciones de nuestros programas con cambios discretos.</p>

<p>Los archivos que nos interesa agregar al <code>tracking</code> se tienen que <code>add</code>ear. (i.e <code>git add .</code>)</p>

<p>Cuando queremos guardar los cambios, es suficiente con <code>commite</code>earlos.</p>

<p>Estos cambios pueden ser consultados(<code>git log</code>) y podemos revertirlos de ser necesario (<code>git reset</code>).</p>

<p>Es útil al jugar single player <code>git</code> que cada cambio sea un <code>feat/feature-name</code>.
Cuando estemos satisfechos con los cambios, realizamos un <code>merge</code> al branch principal (<code>main</code>, o <code>master</code>)</p>

<p><strong>IMPORTANTE</strong> En todo momento solo tendremos dos (2) branches, nuestra rama principal que contiene una version estable del programa
y nuestra rama donde estemos desarrollando <code>features</code> nuevas. de otra forma, es posible que nos enfrentemos a <code>merge conflicts</code>.</p>

<p>Si queremos compartir los cambios a un repositorio remoto (i.e en <code>github</code>) es suficiente con <code>push</code>ear los cambios.</p>

<p>Si queremos obtener cambios de un repositorio remoto, es suficiente con <code>pull</code>earlos (o <code>clone</code>earlos si no tenemos el repo local.)</p>
<h2 id='sesion-2'>sesión 2</h2>
<p>sobre apuntadores, aritmetica de apuntadores, operadores de <code>dereferencia</code> y <code>direccion de</code>.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">mi_entero</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">mi_apuntador</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// aun no apuntamos a nada</span>
  <span class="n">mi_apuntador</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_entero</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>definición</strong>
<aside class="success">
un apuntador es una <code>variable</code> cuyo valor es una <code>dirección de memoria</code>.
</aside></p>

<p>de forma general, declaramos un apuntador con la forma <code>tipo_de_dato *identificador;</code> es legal declarar 
apuntadores para cualquier tipo de dato.</p>
<h3 id='sobre-y-amp'>sobre <code>*</code> y <code>&amp;</code></h3>
<p>las direcciones de memoria se representan numericamente, frecuentemente usando el sistema hexadecimal.
para declarar apuntadores, usamos asteriscos <code>*</code> despues del tipo de dato al que queremos referenciar.</p>

<p>notesé que al declarar <code>mi_apuntador</code> el valor <code>0</code> denota <code>NULL</code> o una dirección INVALIDA
posteriormente, se asigna a <code>mi_apuntador</code> la dirección de memoria de <code>mi_entero</code> usando el operador 
<code>direccion de</code> representado con <code>&amp;</code>.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">int</span> <span class="n">mi_entero</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">apuntador_a_entero</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_entero</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"VALORES:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"&lt;mi_entero:&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mi_entero</span><span class="p">);</span> <span class="c1">// usando el identificador de la variable "tradicional"</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"&lt;VALOR&gt; &lt;apuntador_a_entero&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">apuntador_a_entero</span><span class="p">);</span> <span class="c1">// usando operador '*' "de dereferencia" para obtener valor.</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"DIRECCIONES DE MEMORIA:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"&lt;DIRECCION&gt; &lt;mi_entero&gt; %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mi_entero</span><span class="p">);</span> <span class="c1">// usando el operador '&amp;'  "direccion de" para obtener direccion de memoria</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"&lt;apuntador_a_entero&gt; %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">apuntador_a_entero</span><span class="p">);</span> <span class="c1">// el valor de apuntador_a_entero es una direccion de memoria!</span>

</code></pre></div><h3 id='la-desafortunada-vida-de'>la desafortunada vida de <code>*</code></h3>
<p>recordemos que el simbolo <code>*</code>, <code>asterisco</code> &quot;trabaja tiempo extra&quot;:</p>

<ol>
<li>Es el operador de multiplicación.</li>
<li>Es el simbolo que denota que el tipo de dato de nuestra variable es apuntador (<code>int *mi_apuntador</code>)</li>
<li>Es el operador de <code>dereferencia</code>. se usa para obtener el <strong>VALOR</strong> de una dirección de memoria.</li>
</ol>
<h3 id='la-afortunada-vida-de-amp'>la afortunada vida de <code>&amp;</code></h3>
<p>aunque podriamos argumentar que <code>&amp;</code>, <code>ampercent</code> tambien tiene multiples usos:</p>

<ol>
<li>Se usa para declarar que multiples condiciones logicas tienen que ser verdaderas (<code>&amp;&amp;</code>)</li>
<li>Como operador <code>AND</code> a nivel de bits (<code>baz = foo &amp; bar;</code>)</li>
<li>Como operador <code>dirección de</code>.</li>
</ol>

<p>por los diferentes contextos donde aparece, suele no causar el mismo nivel de confusión que <code>*</code></p>
<h3 id='los-apuntadores-tambien-son-variables'>los apuntadores también son variables!</h3><div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">int</span> <span class="n">mi_arreglo</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">2782</span><span class="p">};</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">mi_apuntador</span> <span class="o">=</span> <span class="n">mi_arreglo</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">" %d "</span><span class="p">,</span> <span class="o">*</span><span class="n">mi_apuntador</span><span class="p">);</span>
  <span class="n">mi_apuntador</span> <span class="o">=</span> <span class="n">mi_apuntador</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// o mi_apuntador++; !</span>
<span class="p">}</span>
</code></pre></div>
<p>recordando la definición de arreglo
<strong>definición</strong>
<aside class="success">
Un arreglo es una colección de elementos, todos del mismo tipo, ordenados de forma consecutiva en memoria.
</aside></p>

<p>por lo tanto, si &quot;aumentamos&quot; el valor de un apuntador, efectivamente estamos cambiando la referencia al dato siguiente consecutivo!
podemos aprovechar eso para visitar cada elemento de un arreglo usando el operador de <code>*</code>.</p>

<p>como nota, al finalizar el ciclo <code>for</code>, el valor de <code>mi_apuntador</code> es una dirección invalida, y por lo tanto
<code>dereferenciarla</code> podria causar comportamiento indeterminado!.</p>

<aside class="notice">
Si en lugar de imprimir los valores del arreglo nos interesaran las direcciones de memoria, 
como cambiaria el cuerpo del ciclo <code>for</code>?
</aside>
<h3 id='notas-importantes'>Notas importantes</h3>
<p>manipular la dirección que guarda un apuntador es generalmente una operación sin riesgo, <code>i.e</code> si un apuntador guarda una
dirección de memoria inválida el programa se comportará correctamente, el riesgo existe al <code>dereferenciar</code> (con <code>*</code>) una referencia ilegal!</p>
<h2 id='sesion-3'>Sesión 3</h2>
<p>Sobre apuntadores a estructuras, apuntadores como argumentos a funciones.</p>
<h3 id='modificar-valores-a-traves-de-referencias'>Modificar valores a traves de referencias</h3>
<p>consideremos la función <code>swap</code> <code>void swap(int *a, int *b);</code> que pretende intercambiar los valores de <code>a</code> y <code>b</code>.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
  <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>En <code>c</code> los argumentos a funciones se pasan por <strong>valor</strong> , es decir: cada función tiene su copia de los argumentos que recibe
y los cambios que sufren no se reflejarán en el resto del programa. Si una función recibe apuntadores y modifica los valores 
referenciados usando <code>*</code> esos cambios <strong>SI</strong> se mostrarán en todo el programa!</p>

<p>notese que al invocar la función swap, puesto que se modificaron los valores de <code>a</code> y <code>b</code> esos cambios se reflejarán desde la función &quot;llamadora&quot; (<code>i.e main</code>).</p>
<h3 id='apuntadores-a-estructuras'>Apuntadores a estructuras</h3><div class="highlight"><pre class="highlight c tab-c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Vector_2d</span><span class="p">;</span>
</code></pre></div>
<p>Puesto que podemos declarar apuntadores de <strong>cualquier</strong> tipo de dato, declarar un apuntador a estructuras es sencillo.
para comodidad (mas no es mandatorio) usamos <code>typedef</code> para definir un alias a nuestra <code>struct</code></p>

<p>ahora es válido declarar <code>Vector_2d *mi_apuntador_a_vector;</code></p>

<p>Para los tipos de datos primitivos <code>int</code>, <code>char</code>, <code>float</code> etc como para estructuras se cumple que si son los argumentos de una función, entonces se pasan por <strong>valor</strong>.
Si una funció recibe un apuntador a estructura y usa <code>*</code> para modificar sus miembros, esos cambios se reflejarán también en la función &quot;llamadora&quot; (<code>i.e main</code>).</p>

<p><code>(*mi_apuntador_a_vector).x = 12.4;</code> es una instrucción válida asumiento que el apuntador esta referenciando una posición legal de memoria.</p>
<h3 id='sintactic-sugar-apuntadores-a-struct'>Sintactic sugar - apuntadores a <code>struct</code></h3>
<p><code>dereferenciar</code> una estructura es una operación tan común que la notación tradicional de <code>*</code> resulta un tanto burda.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">void</span> <span class="nf">square_vector</span><span class="p">(</span><span class="n">Vector_2d</span> <span class="o">*</span><span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// equivalente a (*vector).x = (*vector).x * (*vector).x;</span>
  <span class="n">vector</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="n">vector</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">*</span> <span class="n">vector</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">;</span>
  <span class="c1">// equivalente a (*vector).y = (*vector).y * (*vector).y;</span>
  <span class="n">vector</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="n">vector</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">*</span> <span class="n">vector</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>existe entonces el operador &quot;flechita&quot; <code>-&gt;</code> (es un guión <code>-</code> seguido de un &quot;mayor que&quot; <code>&gt;</code>) es taquigrafía especial que nos permite
<code>dereferenciar</code> rápida y claramente una struct a traves de su apuntador.</p>
<h2 id='sesion-4'>Sesión 4</h2>
<p>Sobre arreglos de apuntadores, y diferencias con arreglos de 2 dimensiones.</p>
<h3 id='arreglos-de-apuntadores-int'>Arreglos de apuntadores int*</h3><div class="highlight"><pre class="highlight c tab-c"><code>  <span class="kt">int</span> <span class="n">arry_1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">44</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">some_int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">12</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">arry_2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">};</span>

  <span class="kt">int</span> <span class="o">*</span><span class="n">mi_arreglo</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">arry_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">some_int</span><span class="p">,</span> <span class="n">arry_2</span> <span class="p">};</span>
</code></pre></div>
<p>Si declaramos un arreglo de tipo <code>int* mi_arreglo[10]</code> , los elementos de <code>mi_arreglo</code> son direcciones de memoria.
Puesto que son referencias, siguen todas las reglas que esperamos, pueden ser <code>*</code> de-referenciados y los cambios que sufran sus valores
se reflejarán en todo el programa.</p>
<div class="highlight"><pre class="highlight c tab-c"><code>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mi_arreglo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">mi_arreglo</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</code></pre></div>
<p>En este ejemplo en particular, el primer elemento de <code>mi_arreglo</code> es una referencia a <code>arry_1</code>
por lo tanto: <code>mi_arreglo[0][1]</code> es una forma legal de acceder al entero <code>22</code> usando notación de corchetes.
Si usaramos únicamente aritmetica de apuntadores <code>*((*mi_arreglo)+1)</code> es la expresión equivalente.</p>
<div class="highlight"><pre class="highlight c tab-c"><code>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mi_arreglo</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">mi_arreglo</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>notece que no es necesario que los miembros de <code>mi_arreglo</code> sean tambien arreglos de enteros, es suficiente con que sea una referencia a un entero.
de esta forma, <code>mi_arreglo[1][0]</code> es una forma legal de accedera a <code>-12</code>. Con aritmetica de apuntadores : <code>**(mi_arreglo+1)</code>.</p>
<div class="highlight"><pre class="highlight c tab-c"><code>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mi_arreglo</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">mi_arreglo</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>Como último ejemplo, consideremos el caso en que queramos obtener el entero <code>40</code>, usando corchetes es trivial: <code>mi_arreglo[2][2]</code>
usando aritmetica de apuntadores: <code>*(*(mi_arreglo+2)+2)</code>. </p>
<h3 id='en-general-sobre-arreglos-de-apuntadores'>en general sobre arreglos de apuntadores.</h3>
<p>Para entender mejor la notación de aritmetica de apuntadores:</p>

<aside class="notice">
  de forma general: <code>*(*(mi_arreglo+i)+j)</code> resolverá el mismo elemento que <code>mi_arreglo[i][j]</code> si y solo
  si son arreglos con tipos completos (i.e NO <code>void*</code>).
</aside>
<h3 id='arreglos-de-apuntadores-char'>Arreglos de apuntadores char*</h3>
<p>consideremos el siguiente programa:</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">many_strings</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
          <span class="s">"hola!"</span><span class="p">,</span>
          <span class="s">"este arreglo tiene muchas frases"</span><span class="p">,</span>
          <span class="s">"todas se pueden acceder"</span><span class="p">,</span>
          <span class="s">"de forma sencilla!"</span>
  <span class="p">};</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">many_strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" %s"</span><span class="p">,</span> <span class="n">many_strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<p>resulta practico que sea un arreglo de apuntadores <code>char*</code> puesto que el contenido del mensaje es constante.
si usaramos un arreglo de tipo <code>char[][]</code>, estariamos obligados a determinar la longitud máxima de nuestros mensajes en tiempo de compilación!</p>

<p>Considera porque un arreglo tipo <code>char*[]</code> no requiere dicha definición? (Aprovecha los conocimientos de la sesión 7 - Organización de memoria)</p>
<h2 id='sesion-5'>Sesión 5</h2>
<p>Sobre apuntadores sin tipo, o <code>void*</code>.</p>
<h3 id='sobre-void'>Sobre void*</h3><div class="highlight"><pre class="highlight c tab-c"><code>  <span class="kt">int</span> <span class="n">mi_entero</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">mi_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_entero</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mi_entero</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mi_ptr</span><span class="p">);</span>
</code></pre></div>
<p>Cuando ignoramos (o no nos interesa) el tipo de dato concreto al que estamos apuntando, pero SI deseamos guardar una referencia para futuros usos
utilizamos apuntadores tipo <code>void*</code>.</p>

<p>En este ejemplo, la dirección de <code>mi_entero</code> y el valor de <code>mi_ptr</code> serán iguales.</p>

<aside class="warning">
  Es ilegal el uso del operador de dereferencia <code>*</code> en apuntadores <code>void*</code>.
</aside>
<div class="highlight"><pre class="highlight c tab-c"><code>  <span class="c1">// ilegal, esto no compila.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">mi_ptr</span><span class="p">);</span>
</code></pre></div>
<p>La razón tendria que ser evidente: al no conocer el tipo de dato concreto al que estamos apuntando, es imposible que sepamos cuantas direcciones de memoria
tenemos que leer para construir el dato concreto.</p>
<div class="highlight"><pre class="highlight c tab-c"><code>  <span class="c1">// esto si es legal</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">mi_helper</span> <span class="o">=</span> <span class="n">mi_ptr</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">mi_helper</span><span class="p">);</span>
</code></pre></div>
<p>Para obtener el valor de un apuntador <code>void*</code> es necesario especificar el tipo de dato concreto al que estamos apuntando, y posteriormente dereferenciarlo.
Esta operación se conoce como <code>typecasting</code> o sencillamente <code>casting</code>.</p>

<p>es posible realizar el <code>cast</code> en una sola linea, i.e: <code>printf(&quot;%d\n&quot;, *(int*)mi_ptr);</code></p>
<h3 id='sobre-aritmetica-de-apuntadores'>Sobre aritmetica de apuntadores</h3><div class="highlight"><pre class="highlight c tab-c"><code>  <span class="kt">int</span> <span class="o">*</span><span class="n">mi_int_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_entero</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">mi_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_entero</span><span class="p">;</span>

  <span class="n">mi_ptr</span><span class="o">++</span><span class="p">;</span>
  <span class="n">mi_int_ptr</span><span class="o">++</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%p != %p"</span><span class="p">,</span> <span class="n">mi_ptr</span><span class="p">,</span> <span class="n">mi_int_ptr</span><span class="p">);</span>
</code></pre></div>
<p>Como vimos en <strong>arimetica de apuntadores</strong> cuando tenemos un apuntador de tipo concreto, lo podemos manipular tal que si se le suma o resta algun número entero,
se calculará la siguiente dirección de memoria valida para ese tipo concreto en particular. Puesto que <code>void*</code> desconoce el tipo, en su lugar se toma el tipo de 
dato mas pequeño que se soporte (i.e <code>char</code>) para completar la operación, generalmente esto significa que si aumentamos en <code>1</code> el valor de un apuntador <code>void*</code> este
apuntará al siguiente <code>byte</code>. **</p>

<p>Considerando el ejemplo, <code>mi_ptr</code> apuntará a una dirección <code>3</code> bytes antes que <code>mi_int_ptr</code>. **</p>

<p>** Nota: Esto puede variar dependiendo de su arquitectura, pero para efectos de esta clase siempre será cierto.</p>
<h1 id='ejercicios'>Ejercicios</h1><h1 id='herramientas'>Herramientas</h1><h2 id='editores-amp-ides'>Editores &amp; IDEs</h2>
<p><a href="https://www.jetbrains.com/clion/">CLion</a> es el IDE oficial del curso. Unicamente se proporcionara soporte institucional a CLion.
<aside class="notice"> Recuerden solicitar su licencia gratuita por estudiantes usando su correo institucional.</aside></p>

<p><a href="https://code.visualstudio.com/">Vs-Code</a> es una opción alternativa para aquellos <strong>hackers</strong> que no tengan miedo de configurar su propio toolchain.</p>

<p><a href="https://spacevim.org/">SpaceVim</a> para aquellos que quieran pasar mas tiempo configurando su IDE que programando.</p>
<h2 id='vcs'>VCS</h2>
<p>Usaremos Git como nuestro <strong>V</strong>ersion <strong>C</strong>ontrol <strong>S</strong>ystem para todos los entregables y ejercicios.
Aunque si lo desean pueden usar una GUI - <strong>G</strong>raphic <strong>U</strong>ser <strong>I</strong>nterface, es <strong>altamente recomendado</strong> que usen la CLI - <strong>C</strong>ommand <strong>L</strong>ine <strong>I</strong>nterface.</p>

<p>Pueden obtener <a href="https://git-scm.com/downloads">Git aquí</a></p>

<table><thead>
<tr>
<th style="text-align: left">Herramienta</th>
<th style="text-align: left">Version</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">git</td>
<td style="text-align: left"><code>&gt;= 2.3</code></td>
</tr>
</tbody></table>
<h2 id='toolchain'>Toolchain</h2>
<p>CLion tiene <code>out-of-the-box</code> configurado correctamente el toolchain necesario, si se desea usar otro IDE (i.e <code>vs-code</code>) es necesario instalar de forma independiente:</p>

<table><thead>
<tr>
<th style="text-align: left">Herramienta</th>
<th style="text-align: left">Version</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">CMake</td>
<td style="text-align: left"><code>&gt;= 3.33</code></td>
</tr>
<tr>
<td style="text-align: left">clang, gcc</td>
<td style="text-align: left"><code>&gt;= 12.0</code>, <code>&gt;= 4.5</code></td>
</tr>
<tr>
<td style="text-align: left">Microsoft™ Visual™ Studio™ C++™</td>
<td style="text-align: left"><code>&gt;= ???</code></td>
</tr>
</tbody></table>

<p>Para los mortales de Microsoft™ Windows™ 10™ CLion usa una version empaquetada de MinGW. Esta es suficiente siempre y cuando NO usemos librerías externas (i.e <code>raylib</code> o <code>Criterion</code>).</p>

<p>Opcionalmente pero <strong>altamente recomendado</strong>, si desean ejecutar las pruebas unitarias de forma local se requiere <a href="https://github.com/Snaipe/Criterion">Criterion</a>.</p>

<p>Para los mortales de Microsoft™ Windows™ 10™ es necesario instalar Microsoft™ Visual™ Studio™ C++™ y Meson de forma independiente, compilar e instalar la librería.</p>

<aside class="success">Se recomienda desinstalar windows y sustituirlo por Ubuntu</aside>

<p>Adicional a esto, yo uso:</p>

<table><thead>
<tr>
<th>Herramienta</th>
<th>Version</th>
</tr>
</thead><tbody>
<tr>
<td>vim</td>
<td><code>&gt;= 8.2</code></td>
</tr>
<tr>
<td>iTerm</td>
<td><code>&gt;= 3</code></td>
</tr>
<tr>
<td>Homebrew</td>
<td><code>&gt;= 3.5</code></td>
</tr>
</tbody></table>

<p>Si algún hacker usa MacOS es <strong>altamente</strong> recomendado que usen <a href="https://brew.sh/">Homebrew</a> como su administrador de paquetes.</p>
<h1 id='guia-de-estilo'>Guía de estilo</h1>
<p>Esta guía de estilo es esencialmente una traducción de la <a href="https://cs50.readthedocs.io/style/c/">guía de Harvard</a> con ligeros cambios.</p>

<p>No existe una “única” forma correcta de formatear código. Pero definitivamente existen <em>varias</em> formas de hacerlo mal. Durante el curso se pedirá que todos los entregables respeten las reglas de estilo aquí dispuestas (similar a como muchas empresas tienen lineamientos de estilo obligatorios). El objetivo es generar código fuente con estilos consistentes independientemente del programador.</p>
<h2 id='longitud-de-linea'>Longitud de línea</h2><div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// Nótese como esta caja de código requiere que el usuario use scroll.</span>

<span class="c1">// These next lines of code first prompt the user to give two integer values and then multiplies those two integer values together so they can be used later in the program</span>
<span class="kt">int</span> <span class="n">first_collected_integer_value_from_user</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Integer please: "</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">second_collected_integer_value_from_user</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Another integer please: "</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">product_of_the_two_integer_values_from_user</span> <span class="o">=</span> <span class="n">first_collected_integer_value_from_user</span> <span class="o">*</span> <span class="n">second_collected_integer_value_from_user</span><span class="p">;</span>
</code></pre></div>
<p>Por convenciones históricas, la longitud máxima de una línea de código será de 80 caracteres. </p>

<p>Por decisiones de diseño de IBM, inicialmente los monitores tenían la capacidad de renderizar 24 líneas de texto cada una con hasta 80 caracteres. Ahora es evidentemente obsoleto pero el límite de 80 caracteres es aún una restricción frecuente para evitar <code>line-wraps</code> o tener barras de <code>scroll</code>.  En cualquier forma, si requieres más de 80 caracteres para una sola instrucción es posible que necesites pensar en tu esquema de nombres de variables, o reconsiderar el diseño general de tu solución.</p>

<p>En otros lenguajes (javascript en particular) resulta complicado respetar este límite y otras reglas de estilo aplican (i.e segmentar una instrucción con saltos de linea <code>\n</code>)</p>
<h2 id='comentarios'>Comentarios</h2>
<p>El objetivo de los comentarios es que el código fuente sea más legible. Es importante recalcar que los comentarios ayudan no solo a otros programadores, ¡ayudan también al autor inicial! Cuando pasan horas, días, semanas o años después de que se implementó algo y se quiere recordar alguna decisión de diseño o detalle importante es más fácil si se deja un <strong>breve</strong> recordatorio en lenguaje natural. Pocos y pobres comentarios no resultan de ayuda, demasiados comentarios caen en la redundancia (o son resultado de implementaciones malas que requieren profundas explicaciones). Cada programador tendrá que decidir cuál es el balance correcto. Un inicio es comentar cada vez que se necesite responder alguna de estas preguntas:</p>

<ol>
<li>¿Que hace este bloque?</li>
<li>¿Porque implemente este bloque de esta forma?</li>
</ol>
<h3 id='en-linea'>en linea</h3><div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// Convert Fahrenheit to Celsius</span>
<span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">9</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>Para los comentarios dentro de funciones, usa comentarios <code>inline</code> y mantenlos <strong>breves</strong> (i.e una sola línea), de otra forma interferirían con la lectura del código fuente. Escribe los comentarios en la línea inmediatamente superior a la pieza de código que se está describiendo. Recuerda dejar un espacio después del inicio del comentario <code>//</code>.</p>

<aside class="warning">
  No mezcles código y comentario en la misma linea! i.e
 <code>int foo = 12; //asigna un valor al entero </code>
</aside>
<h3 id='en-funciones'>en funciones</h3><div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// Returns the square of n</span>
<span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Las funciones son perfectas candidatas para breves comentarios significativos: resulta útil que cada función tenga justo antes de su <strong>implementación</strong> una breve descripción de que hace dicha subrutina. Generalmente no es necesario comentar <code>main</code>.</p>

<aside class="notice">
  No es necesario comentar el comportamiento de ciclos de repetición.
  como <code>for</code> o <code>while</code>
</aside>
<h3 id='en-archivos'>en archivos</h3><div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">//</span>
<span class="c1">// Created by Josean Camarena on 07/07/22.</span>
<span class="c1">// Implemented by: $STUDENT$ </span>
<span class="c1">// Sorts a given collection with various algorithms.</span>
<span class="c1">// </span>
</code></pre></div>
<p>Al principio de cada archivo <code>.c</code> o <code>.h</code> resulta útil agregar la información de autor y fecha con una breve descripción sobre que hace la librería.</p>
<h2 id='estructuras-condicionales'>estructuras condicionales</h2>
<p>La guía de estilo pretende resaltar el contenido de los bloques condicionales, y clarificar la expresión de la condicional.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is positive</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is negative</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is zero</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id='las-estructuras-condicionales-tienen-que-respetar'>Las estructuras condicionales tienen que respetar</h3>
<ul>
<li>las llaves se alinean correctamente, <em>cada una en su propia linea</em>, haciendo énfasis en lo que contiene cada bloque de código. </li>
<li>cada <code>if</code> tiene un espacio antes de abrir el paréntesis de la expresión condicional.</li>
<li>cada llamada a <code>printf</code> esta correctamente indentada.</li>
<li>existe un espacio separando <code>&lt;</code> y <code>&gt;</code> de los valores a comparar.</li>
<li>No se tiene espacio inmediatamente después de abrir <code>(</code> paréntesis o inmediatamente antes de <code>)</code> cerrarlo.</li>
</ul>

<aside class="notice">
 Aunque la indentación tradicional de <code>c</code> son de 4 espacios, se permite tener indentación de 2 espacios siempre y cuando seamos <strong>consistentes</strong>
</aside>
<h3 id='sobre-la-apertura-de-llaves'>sobre la apertura de llaves</h3><div class="highlight"><pre class="highlight c tab-c"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is negative</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is negative</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Frecuentemente encontraremos llaves en la misma linea que la condición. Esto no es recomendado pero si se desea sera permitido.</p>
<h3 id='definitivamente-asi-no'>definitivamente así no</h3><div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// esto es terrible y no será aceptado.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is negative</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">else</span>
    <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x is negative</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>Estos estilos no serán aceptados independientemente de si la solución es programaticamente correcta. </p>
<h2 id='switches'>Switches</h2>
<p>Para la sentencia <code>switch</code> </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"n is -1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"n is 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"n is neither -1 nor 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>es necesario que:</p>

<ul>
<li>cada llave se encuentra en su propia linea;</li>
<li>existe un espacio entre la palabra reservada <code>switch</code> y la expresión a evaluar;</li>
<li>no se tiene espacio inmediatamente después de abrir <code>(</code> paréntesis o inmediatamente antes de <code>)</code> cerrarlo.</li>
<li>las condiciones de cada caso se encuentran correctamente indentadas en relación al inicio de la expresión. </li>
<li>el bloque de código correspondiente a cada caso se encuentra correctamente indentado en relación a la expresión de ese caso; y</li>
<li>todos los <code>case</code> (incluyendo <code>default</code>) termina con <code>break</code>.</li>
</ul>

<p>Sobre el ultimo punto, es importante recalcar que aunque <code>c</code> permite <code>fallthrough</code> en los casos (i.e no terminar explícitamente un caso) esto no será permitido. </p>
<h2 id='funciones'>Funciones</h2><h3 id='sobre-main'>Sobre <code>main</code></h3>
<p>Para declarar <code>main</code></p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✓ correcto</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre></div>
<p>de acuerdo con el estándar <a href="http://en.wikipedia.org/wiki/C99">C99</a>, la declaración de la función <code>main</code> será tan explicita como sea posible, en su version mas simple regresando un <code>int</code> y descartando <code>argc</code> y <code>argv</code> de forma explicita con <code>void</code>.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✓ correcto</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>de otra forma, si se requieren <code>argc</code> y <code>argv</code> estos pueden ser declarados como un arreglo de <code>char</code>.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✓ correcto</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>O si se prefiere, como un <code>char**</code>.</p>

<p>recuerda no dejar vacíos los argumentos de <code>main</code></p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✗ incorrecto</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>o declarar <code>main</code> tal que regrese un tipo de dato diferente de <code>int</code>.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✗ incorrecto</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>o dejar implícito el tipo de dato de retorno. </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✗ incorrecto</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<aside class="notice">
Para nuestras propias funciones, se seguirá el mismo estilo, con las llaves de apertura y cierre cada una en su propia linea y el tipo de dato que regresa la función en la misma linea que el identificador. 
</aside>
<h2 id='indentacion'>Indentación</h2>
<p>Decide si tu estilo de indentación sera de 2 espacios por <code>\t</code>  o 4 espacios y mantén el estilo <strong>consistente</strong>. Indenta los bloques de código de tu programa para que sea evidente que subrutinas están dentro de otras rutinas. Si usas la tecla de tabulador, asegúrate que tu editor de texto este configurado para sustituir <code>\t</code> por espacios. Esto es porque el carácter tabulador <code>\t</code> se renderiza de forma ligeramente distinta en cada editor.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// Print command-line arguments one per line</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>considera este programa, nótese que:</p>

<ul>
<li>Es evidente que subrutina corresponde a cada ciclo de repetición <code>for</code>.</li>
<li>Cada llave tanto de apertura como de cierre se encuentra en su propia linea.</li>
<li>La expresión de condición e incremento se encuentran en la misma linea.</li>
</ul>
<h2 id='ciclos-de-repeticion'>Ciclos de repetición</h2><h3 id='for'>for</h3>
<p>para ciclos de repetición <code>for</code> </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LIMIT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">LIMIT</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">LIMIT</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Do something</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Cuando necesites variables temporales de iteración, usa en primera instancia <code>i</code>, después <code>j</code>, y por ultimo <code>k</code>, a menos que el ciclo tenga algún significado semántico que sea util usar nombres mas específicos (i.e <code>row</code> y <code>col</code> para iterar sobre arreglos de dos dimensiones que representan una matriz).</p>

<p>Si en algún momento consideras que necesitas mas de 3 ciclos anidados, es muy probable que necesites reconsiderar el diseño de tu solución. </p>
<h3 id='while'>while</h3>
<p>Los ciclos <code>while</code> se declararán como sigue: </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Do something</span>
<span class="p">}</span>
</code></pre></div>
<p>nótese que:</p>

<ul>
<li>cada llave se encuentra en su propia linea;</li>
<li>existe un espacio justo después de la palabra reservada <code>while</code>;</li>
<li>no se tiene espacio inmediatamente después de abrir <code>(</code> paréntesis o inmediatamente antes de <code>)</code> cerrarlo; y</li>
<li>el cuerpo del ciclo (en este caso un comentario) esta correctamente indentado.</li>
</ul>
<h3 id='do-while'>do ... while</h3>
<p>Los ciclos <code>do..while</code> se declararán como sigue: </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="k">do</span>
<span class="p">{</span>
    <span class="c1">// Do something</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>
</code></pre></div>
<p>Nótese que:</p>

<ul>
<li>cada llave se encuentra en su propia linea;</li>
<li>la palabra reservada <code>do</code> se encuentra en su propia linea.</li>
<li>existe un espacio justo después de la palabra reservada <code>while</code>;</li>
<li>la condición se encuentra en la misma linea que la palabra reservada <code>while</code>;</li>
<li>no se tiene espacio inmediatamente después de abrir <code>(</code> paréntesis o inmediatamente antes de <code>)</code> cerrarlo; y</li>
<li>el cuerpo del ciclo (en este caso un comentario) esta correctamente indentado.</li>
</ul>
<h2 id='apuntadores'>Apuntadores</h2>
<p>Los apuntadores seguirán las siguiente reglas de estilo: </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// ✓ correcto</span>
</code></pre></div>
<p>cuando declaramos un apuntador, el símbolo <code>*</code> se encuentra de forma adyacente al identificador de la variable. </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// ✗ incorrecto</span>
</code></pre></div>
<p>No de forma adyacente al tipo de dato.</p>
<h2 id='variables'>Variables</h2><h3 id='sobre-nombres'>Sobre nombres</h3>
<p>Puesto que usaremos el estándar <a href="http://en.wikipedia.org/wiki/C99">C99</a>, no definan todas las variables de un bloque en la parte superior del bloque.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LIMIT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>declaren las variables tan cerca a su primer uso como sea posible,asimismo las variables tendrán el alcance (<code>scope</code>) mínimo indispensable. por ejemplo, si la variable <code>i</code> solo se necesita para la iteración de un ciclo, declara la variable en la cabecera del ciclo. </p>

<p>Para variables cuya única funcionalidad es iteración, los nombres <code>i</code>, <code>j</code> y <code>k</code> son suficiente, para otras variables sera util encontrar nombres semánticamente relevantes que describan de forma <strong>concisa</strong> cual es su uso. Por ejemplo, <code>sum</code> si la variable es el resultado de una expresión de adición. Si la variable requiere de dos o mas palabras (i.e <code>is_ready</code>), usa un guion bajo <code>_</code> para separarlas. Esta es una convención popular en lenguajes como <code>C</code> y <code>ruby</code> . otro lenguajes prefieren <code>camelCase</code> i.e <code>isReady</code>.</p>
<h3 id='sobre-declaraciones'>sobre declaraciones</h3>
<p>Si declaramos multiples variables del mismo tipo, es correcto declararlas en la misma linea, o una por linea.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✓ correcto</span>
<span class="kt">int</span> <span class="n">quarters</span><span class="p">,</span> <span class="n">dimes</span><span class="p">,</span> <span class="n">nickels</span><span class="p">,</span> <span class="n">pennies</span><span class="p">;</span>
</code></pre></div>
<p>Si se decide declararlas en la misma linea, esta prohibido inicializar solamente algunas variables. </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✗ incorrecto</span>
<span class="kt">int</span> <span class="n">quarters</span><span class="p">,</span> <span class="n">dimes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nickels</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">pennies</span><span class="p">;</span>
</code></pre></div>
<p>Es importante declarar apuntadores y tipos primitivos por su cuenta, cada uno en su linea.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✓ correcto</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div>
<p>No declares apuntadores, y tipos de datos primitivos en la misma linea. </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// ✗ incorrecto</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div><h2 id='tipos-estructurados'>Tipos estructurados</h2>
<p>Para declarar un tipo <code>struct</code> compuesto:</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">dorm</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">student</span><span class="p">;</span>
</code></pre></div>
<p>nótese que:</p>

<ul>
<li>las palabras reservadas <code>typedef</code> y <code>struct</code> se encuentran en la misma linea, en su propia linea;</li>
<li>las llaves de apertura y cierre se encuentran en su propia linea;</li>
<li>los miembros de la estructura se encuentran correctamente indentados, uno por linea; y</li>
<li>el identificador del tipo de dato compuesto <code>student</code> se encuentra en su propia linea.</li>
</ul>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="c">c</a>
          </div>
      </div>
    </div>
  </body>
</html>
